% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/k_means.R
\name{k_means}
\alias{k_means}
\alias{profile_k}
\alias{augment.kmeans}
\alias{predict.k_means}
\alias{plot.k_means}
\alias{autoplot.k_means}
\alias{chart.k_means}
\title{K-means clustering}
\usage{
k_means(
  x,
  k,
  centers = k,
  iter.max = 10L,
  nstart = 1L,
  algorithm = c("Hartigan-Wong", "Lloyd", "Forgy", "MacQueen"),
  trace = FALSE,
  keep.data = TRUE
)

profile_k(x, fun = kmeans, method = "wss", k.max = NULL, ...)

\method{augment}{kmeans}(x, data, ...)

\method{predict}{k_means}(object, ...)

\method{plot}{k_means}(
  x,
  y,
  data = x$data,
  choices = 1L:2L,
  col = NULL,
  c.shape = 8,
  c.size = 3,
  ...
)

\method{autoplot}{k_means}(
  object,
  data = object$data,
  choices = 1L:2L,
  alpha = 1,
  c.shape = 8,
  c.size = 3,
  theme = NULL,
  use.chart = FALSE,
  ...
)

\method{chart}{k_means}(data, ..., type = NULL, env = parent.frame())
}
\arguments{
\item{x}{A data frame or a matrix with numeric data}

\item{k}{The number of clusters to create, or a set of initial cluster
centers. If a number, a random set of initial centers are computed first.}

\item{centers}{Idem (\code{centers} is synonym to \code{k})}

\item{iter.max}{Maximum number of iterations (10 by default)}

\item{nstart}{If \code{k} is a number, how many random sets should be chosen?}

\item{algorithm}{The algorithm to use. May be abbreviated. See
\code{\link[stats:kmeans]{stats::kmeans()}} for more details about available algorithms.}

\item{trace}{Logical or integer. Should process be traced. Higher value
produces more tracing information.}

\item{keep.data}{Do we keep the data in the object? If \code{TRUE} (by default),
a richer set of methods could be applied to the resulting object, but it
takes more space in memory. Use \code{FALSE} if you want to save RAM.}

\item{fun}{The kmeans clustering function to use, \code{kmeans()} by default.}

\item{method}{The method used in \code{\link[=profile_k]{profile_k()}}: \code{"wss"} (by default, total
within sum of square), \code{"silhouette"} (average silhouette width) or
\code{"gap_stat"} (gap statistics).}

\item{k.max}{Maximum number of clusters to consider (at least two). If not
provided, a reasonable default is calculated.}

\item{...}{Other arguments transmitted to \code{\link[factoextra:fviz_nbclust]{factoextra::fviz_nbclust()}}.}

\item{data}{The original data frame}

\item{object}{The \emph{k_means}* object}

\item{y}{Not used}

\item{choices}{The axes (variables) to plot (first and second by default)}

\item{col}{Color to use}

\item{c.shape}{The shape to represent cluster centers}

\item{c.size}{The size of the shape representing cluster centers}

\item{alpha}{Semi-transparency to apply to points}

\item{theme}{The ggplot theme to apply to the plot}

\item{use.chart}{If \code{TRUE} use \code{\link[=chart]{chart()}}, otherwise, use \code{\link[=ggplot]{ggplot()}}.}

\item{type}{Not used here}

\item{env}{Not used here}
}
\value{
\code{\link[=k_means]{k_means()}} creates an object of classes \strong{k_means} and \strong{kmeans}.
\code{\link[=profile_k]{profile_k()}} is used for its side-effect of creating a plot that should
help to chose the best value for \code{k}.
}
\description{
Perform a k-means clustering analysis using the
\code{\link[stats:kmeans]{stats::kmeans()}} function in {stats} but creating a \strong{k_means} object
that possibly embeds the original data with the analysis for a richer set
of methods.
}
\examples{
data(iris, package = "datasets")
iris_num <- iris[, -5] # Only numerical variables
library(chart)

# Profile k is to be taken only asx a (useful) indication!
profile_k(iris_num) # 2, maybe 3 clusters
iris_k2 <- k_means(iris_num, k = 2)
chart(iris_k2)

iris_k3 <- k_means(iris_num, k = 3, nstart = 20L) # Several random starts
chart(iris_k3)

# Get clusters and compare with Species
iris3 <- augment(iris_k3, iris) # Use predict() to just get clusters
head(iris3)
table(iris3$.cluster, iris3$Species) # setosa OK, the other are mixed a bit
}
